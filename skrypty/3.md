# Zmienne i port szeregowy

*Czego się nauczyć*

### Zmienne - pamięć programu

Dotychczas budowane układy były bazowane na prostej reakcji na bodziec - wciśnięcie przycisku uruchamiało blok kodu, zapalało lampkę lub całym działaniem sterował zegar. Czasami jednak chcemy zbudować układ, którego działanie będzie zależało od stanu, w którym się znajduje. Innymi słowy, chcemy by reagował nie tylko na pojedyńcze działania, ale także na ich serie.

Zmienna jest nazwą wydzielonego miejsca w pamięci mikrokontrolera. Komputery są skonstruowane tak, że ich pamięć jest ułożona w bardzo ścisły sposób, z tego powodu każde miejsce w pamięci musi zostać odpowiednio oznaczone (to nie do końca prawda, wyjątki od tej reguły są zbyt skomplikowane na jeden poradnik ;) ) . Przyjrzyjmy się więc temu jak wyglądają:

```c
int liczba = 0;
float ulamek = 0.5;
char napis[] = "Ten napis ma 21 liter";
```
Każda zmienna musi być *zadeklarowana* - oznacza to, że w pamięci zostaje przydzielone jej miejsce. Deklaracja zmiennej ma postać `typ nazwa`. Zmienne mają typy, które mówią płytce, ile miejsca w pamięci należy przydzielić i w jaki sposób przetłumaczyć ją na język komputera.

W tym samouczku są wykorzystane trzy typy zmiennych: `int` od angielskiego integer - oznacza liczby całkowite, `float` ułamki, a `char` - znak. Napisy w C definiuje się jako ciągi znaków - stąd klamra po nazwie zmiennej. Więcej o takich ciągach (czyli tablicach) w następnych samouczkach - na razie potrzebujemy tylko napisów.

Zmienne nie muszą mieć raz przydzielonej wartości - mogą ją zmieniać w czasie programu, na przykład:

```c
int x = 0;
x = x + 3;
// x jest teraz równe 3
```

### Wykorzystanie zmiennych do przechowywania stanu

Złóżmy następujący układ:

![Trzy lampki i przycisk przy jednym arduino]()

I uruchommy następujący program:

```c
//zadeklarujmy zmienne
int stanPrzycisku = 0;
int czyJestWcisniety = 0;

void setup()
{
  //ustawmy piny
  pinMode(2,INPUT_PULLUP);
  pinMode(11,OUTPUT);
  pinMode(12,OUTPUT);
  pinMode(13,OUTPUT);
  //zapalmy pierwsze swiatlo
  digitalWrite(11,LOW);
}

void loop()
{
  //jesli przycisk jest wlaczony i pierwszy raz o tym wiemy
  if(digitalRead(2)==LOW)
  {
    if(czyJestWcisniety==0)
    {
      //zgas stare swiatla, zmien licznik,
      //sprawdz, czy nie jest za wysoki i zapal nowe
      digitalWrite(11+stanPrzycisku,LOW);
      stanPrzycisku = stanPrzycisku + 1;
      if(stanPrzycisku > 2)stanPrzycisku = 0;
      digitalWrite(11+stanPrzycisku,HIGH);
      //ustaw flage, aby przycisk zadzialal tylko raz
      czyJestWcisniety = 1;
    }
  }
  //przy zwolnieniu przycisku ustaw flage,
  //by mozna bylo go wcisnac raz jeszcze
  else czyJestWcisniety = 0;
}
```

Program wykorzystuje dwie zmienne: `stanPrzycisku` przechowuje numer lampki do zapalenia, zaś `czyJestWcisniety` pilnuje tego, żeby warunek wcisnięcia przycisku zareagował tylko raz. Gdyby go nie było (co możesz sprawdzić usuwając jego ustawianie z kodu), przyciski zmieniałyby się tak szybko, że nie byłoby to zauważalne.

### Port szeregowy

Kabel zasilający Arduino możę posłużyć jako medium do komunikacji z komputerem. Otwórz opcję *jaką* w menu Arduino IDE. Pojawi się okno, w którym wyświetlane są komunikaty z płytki. Następnie wpisz i uruchom następujący program:

```c
//zadeklarujmy zmienne
int stanPrzycisku = 0;
int czyJestWcisniety = 0;

void setup()
{
  //uruchommy port szeregowy
  Serial.begin(9600);
  //ustawmy piny
  pinMode(2,INPUT_PULLUP);
  pinMode(11,OUTPUT);
  pinMode(12,OUTPUT);
  pinMode(13,OUTPUT);
  //zapalmy pierwsze swiatlo
  digitalWrite(11,LOW);
}

void loop()
{
  //jesli przycisk jest wlaczony i pierwszy raz o tym wiemy
  if(digitalRead(2)==LOW)
  {
    if(czyJestWcisniety==0)
    {
      //zgas stare swiatla, zmien licznik,
      //sprawdz, czy nie jest za wysoki i zapal nowe
      digitalWrite(11+stanPrzycisku,LOW);
      stanPrzycisku = stanPrzycisku + 1;
      if(stanPrzycisku > 2)stanPrzycisku = 0;
      digitalWrite(11+stanPrzycisku,HIGH);
      //ustaw flage, aby przycisk zadzialal tylko raz
      czyJestWcisniety = 1;
      //Napisz, jakie swiatlo sie swieci
      Serial.print("Obecnie zapalone jest swiatlo: ");
      Serial.println(stanPrzycisku);
    }
  }
  //przy zwolnieniu przycisku ustaw flage,
  //by mozna bylo go wcisnac raz jeszcze
  else czyJestWcisniety = 0;
}
```

Ten przyklad ilustruje, jak korzystac w portu do wypluwania wynikow. Oczywiście komunikacja w drugą stronę też działa, ale będzie to przedstawione w następnym poradniku.

### Kółko i krzyżyk

Do tego ćwiczenia będzie potrzebne dziesięć przycisków, podpiętych pod porty 2-11. Rysunek przedstawia ułożenie takiego układu:

![Trzy na trzy przyciski i jeden reset - wszystkie na rezystorach]()

Program będzie wykorzystywał dziewięć zmiennych dla przechowania pól, jeden do aktualnego gracza.

Kod:

```c
//Zadeklarujmy zmienne
char pole11[] = " "; char pole12[] = " "; char pole13[] = " ";
char pole21[] = " "; char pole22[] = " "; char pole23[] = " ";
char pole31[] = " "; char pole32[] = " "; char pole33[] = " ";
int aktywnyGracz = 0;

void setup()
{
  pinMode(2,INPUT_PULLUP);
  pinMode(3,INPUT_PULLUP);
  pinMode(4,INPUT_PULLUP);
  pinMode(5,INPUT_PULLUP);
  pinMode(6,INPUT_PULLUP);
  pinMode(7,INPUT_PULLUP);
  pinMode(8,INPUT_PULLUP);
  pinMode(9,INPUT_PULLUP);
  pinMode(10,INPUT_PULLUP);
  pinMode(11,INPUT_PULLUP);
  Serial.begin(9600);
}

void loop()
{
  if(digitalRead(2,LOW))
  {
    if(pole11 == " ")
    {
      if(aktywnyGracz == 0)
        {
          pole11 = "X";
          aktywnyGracz = 1;
        }
      else
        {
          pole11 = "O";
          aktywnyGracz = 0;
        }
    }
  }
  //kod zostal scisniety, gdyz jest powtarzany
  //kopiuj wklej 8 razy i zmien cyferki
  if(digitalRead(3,LOW))
    if(pole12 == " "){
      if(aktywnyGracz == 0){pole12 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(4,LOW))
    if(pole13 == " "){
      if(aktywnyGracz == 0){pole13 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(5,LOW))
    if(pole21 == " "){
      if(aktywnyGracz == 0){pole21 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(6,LOW))
    if(pole22 == " "){
      if(aktywnyGracz == 0){pole22 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(7,LOW))
    if(pole23 == " "){
      if(aktywnyGracz == 0){pole23 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(8,LOW))
    if(pole31 == " "){
      if(aktywnyGracz == 0){pole31 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(9,LOW))
    if(pole32 == " "){
      if(aktywnyGracz == 0){pole32 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  if(digitalRead(10,LOW))
    if(pole33 == " "){
      if(aktywnyGracz == 0){pole33 = "X"; aktywnyGracz = 1;}
      else {pole11 = "O";aktywnyGracz = 0;}
    }
  //ostatni przycisk resetuje stan gry
  if(digitalRead(11,LOW))
    {pole11=" ";pole12=" ";pole13=" ";
    pole21=" ";pole22=" ";pole23=" ";
    pole31=" ";pole32=" ";pole33=" ";}
  //ostatni blok kodu drukuje stan gry
  Serial.print("+---+\n|");
  Serial.print(pole11);Serial.print(pole12);Serial.print(pole13);Serial.print("|\n|");
  Serial.print(pole21);Serial.print(pole22);Serial.print(pole23);Serial.print("|\n|");
  Serial.print(pole31);Serial.print(pole32);Serial.print(pole33);Serial.println("|\n+---+");
}

```

Ufff... Jak widać, program zawiera bardzo dużo pisania i wiele powtórzeń. Stąd też cały program aż prosi się o to, aby go uprościć - i uproszczenia te są częscią programowania.

### Pętle

*teoria*

### Tablice

*teoria*

### Zadanie

Uprościć program powyżej tak, aby powtarzał jak najmniej kodu
